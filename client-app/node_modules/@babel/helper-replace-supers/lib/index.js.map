{"version":3,"names":["_helperEnvironmentVisitor","require","_helperMemberExpressionToFunctions","_helperOptimiseCallExpression","_template","_traverse","_t","assignmentExpression","booleanLiteral","callExpression","cloneNode","identifier","memberExpression","sequenceExpression","stringLiteral","thisExpression","ns","exports","environmentVisitor","default","skipAllButComputedKey","getPrototypeOfExpression","objectRef","isStatic","file","isPrivateMethod","targetRef","addHelper","visitor","traverse","visitors","merge","Super","path","state","node","parentPath","isMemberExpression","object","handle","unshadowSuperBindingVisitor","Scopable","refName","binding","scope","getOwnBinding","name","rename","specHandlers","memoise","superMember","count","computed","property","memo","maybeGenerateMemoised","memoiser","set","prop","has","get","_get","_getThisRefs","thisRefs","proto","getObjectRef","this","isDerivedConstructor","thisRef","generateDeclaredUidIdentifier","value","isInStrictMode","destructureSet","buildCodeFrameError","call","args","optimiseCall","optionalCall","delete","template","expression","ast","looseHandlers","Object","assign","getSuperRef","_getSuperRef","_getSuperRef2","ReplaceSupers","constructor","opts","_opts$constantSuper","methodPath","isClassMethod","kind","superRef","isObjectMethod","static","isStaticBlock","isPrivate","isMethod","constantSuper","isLoose","replace","refToPreserve","handler","memberExpressionToFunctions","bind","boundGet"],"sources":["../src/index.ts"],"sourcesContent":["import type { File } from \"@babel/core\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport memberExpressionToFunctions from \"@babel/helper-member-expression-to-functions\";\nimport type { HandlerState } from \"@babel/helper-member-expression-to-functions\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport template from \"@babel/template\";\nimport traverse from \"@babel/traverse\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\nimport {\n  assignmentExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  identifier,\n  memberExpression,\n  sequenceExpression,\n  stringLiteral,\n  thisExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nif (!process.env.BABEL_8_BREAKING) {\n  if (!USE_ESM) {\n    if (!IS_STANDALONE) {\n      // eslint-disable-next-line no-restricted-globals\n      const ns = require(\"@babel/helper-environment-visitor\");\n      // eslint-disable-next-line no-restricted-globals\n      exports.environmentVisitor = ns.default;\n      // eslint-disable-next-line no-restricted-globals\n      exports.skipAllButComputedKey = ns.skipAllButComputedKey;\n    }\n  }\n}\n\ntype ThisRef =\n  | {\n      memo: t.AssignmentExpression;\n      this: t.Identifier;\n    }\n  | { this: t.ThisExpression };\n/**\n * Creates an expression which result is the proto of objectRef.\n *\n * @example <caption>isStatic === true</caption>\n *\n *   helpers.getPrototypeOf(CLASS)\n *\n * @example <caption>isStatic === false</caption>\n *\n *   helpers.getPrototypeOf(CLASS.prototype)\n */\nfunction getPrototypeOfExpression(\n  objectRef: t.Identifier,\n  isStatic: boolean,\n  file: File,\n  isPrivateMethod: boolean,\n) {\n  objectRef = cloneNode(objectRef);\n  const targetRef =\n    isStatic || isPrivateMethod\n      ? objectRef\n      : memberExpression(objectRef, identifier(\"prototype\"));\n\n  return callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nconst visitor = traverse.visitors.merge<\n  HandlerState<ReplaceState> & ReplaceState\n>([\n  environmentVisitor,\n  {\n    Super(path, state) {\n      const { node, parentPath } = path;\n      if (!parentPath.isMemberExpression({ object: node })) return;\n      state.handle(parentPath);\n    },\n  },\n]);\n\nconst unshadowSuperBindingVisitor = traverse.visitors.merge<{\n  refName: string;\n}>([\n  environmentVisitor,\n  {\n    Scopable(path, { refName }) {\n      // https://github.com/Zzzen/babel/pull/1#pullrequestreview-564833183\n      const binding = path